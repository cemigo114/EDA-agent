"""
CodeAgent: SystemVerilog RTL Generation and Refinement

Generates synthesizable SystemVerilog code for FIFO implementation
with Gray code pointers, clock domain crossing safety, and self-correction.
"""

from typing import Dict, Any, List, Optional, Tuple
from dataclasses import dataclass
from pathlib import Path
import re
import subprocess
import tempfile

from .base_agent import BaseAgent, AgentConfig
from .spec_agent import FIFOSpecification


@dataclass
class CodeGenerationResult:
    """Result of code generation"""
    module_code: str
    syntax_valid: bool
    warnings: List[str]
    errors: List[str]
    file_path: Optional[str] = None


class RTLTemplates:
    """SystemVerilog RTL code templates"""
    
    @staticmethod
    def get_async_fifo_template() -> str:
        return '''
// Parameterizable Asynchronous FIFO with Gray Code Pointers
// Generated by Agentic AI EDA System

module async_fifo #(
    parameter FIFO_DEPTH = 16,
    parameter DATA_WIDTH = 8,
    parameter ADDR_WIDTH = $clog2(FIFO_DEPTH),
    parameter ALMOST_FULL_THRESHOLD = 2,
    parameter ALMOST_EMPTY_THRESHOLD = 2
)(
    // Write interface
    input  wire                 wr_clk,
    input  wire                 wr_rst_n,
    input  wire                 wr_en,
    input  wire [DATA_WIDTH-1:0] wr_data,
    output reg                  full,
    output reg                  almost_full,
    
    // Read interface  
    input  wire                 rd_clk,
    input  wire                 rd_rst_n,
    input  wire                 rd_en,
    output reg  [DATA_WIDTH-1:0] rd_data,
    output reg                  empty,
    output reg                  almost_empty
);

    // Memory array
    reg [DATA_WIDTH-1:0] fifo_mem [0:FIFO_DEPTH-1];
    
    // Gray code pointers (one extra bit for full/empty detection)
    reg [ADDR_WIDTH:0] wr_ptr_gray, wr_ptr_gray_next;
    reg [ADDR_WIDTH:0] rd_ptr_gray, rd_ptr_gray_next;
    
    // Binary pointers for memory addressing
    reg [ADDR_WIDTH:0] wr_ptr_bin, wr_ptr_bin_next;
    reg [ADDR_WIDTH:0] rd_ptr_bin, rd_ptr_bin_next;
    
    // Synchronized pointers for flag generation
    reg [ADDR_WIDTH:0] wr_ptr_gray_sync, wr_ptr_gray_sync_r;
    reg [ADDR_WIDTH:0] rd_ptr_gray_sync, rd_ptr_gray_sync_r;

    //==========================================================================
    // Write Clock Domain
    //==========================================================================
    
    // Write pointer generation
    always @(posedge wr_clk or negedge wr_rst_n) begin
        if (!wr_rst_n) begin
            wr_ptr_bin <= 0;
            wr_ptr_gray <= 0;
        end else begin
            wr_ptr_bin <= wr_ptr_bin_next;
            wr_ptr_gray <= wr_ptr_gray_next;
        end
    end
    
    // Write pointer next value logic
    always @(*) begin
        wr_ptr_bin_next = wr_ptr_bin + (wr_en & ~full);
        wr_ptr_gray_next = (wr_ptr_bin_next >> 1) ^ wr_ptr_bin_next;
    end
    
    // Memory write
    always @(posedge wr_clk) begin
        if (wr_en && !full) begin
            fifo_mem[wr_ptr_bin[ADDR_WIDTH-1:0]] <= wr_data;
        end
    end
    
    // Synchronize read pointer to write clock domain
    always @(posedge wr_clk or negedge wr_rst_n) begin
        if (!wr_rst_n) begin
            rd_ptr_gray_sync_r <= 0;
            rd_ptr_gray_sync <= 0;
        end else begin
            rd_ptr_gray_sync_r <= rd_ptr_gray;
            rd_ptr_gray_sync <= rd_ptr_gray_sync_r;
        end
    end
    
    // Generate full and almost_full flags
    always @(*) begin
        full = (wr_ptr_gray_next == {~rd_ptr_gray_sync[ADDR_WIDTH:ADDR_WIDTH-1], 
                                     rd_ptr_gray_sync[ADDR_WIDTH-2:0]});
    end
    
    // Almost full generation
    wire [ADDR_WIDTH:0] wr_ptr_bin_temp = wr_ptr_bin + ALMOST_FULL_THRESHOLD;
    wire [ADDR_WIDTH:0] wr_ptr_gray_temp = (wr_ptr_bin_temp >> 1) ^ wr_ptr_bin_temp;
    
    always @(*) begin
        almost_full = (wr_ptr_gray_temp == {~rd_ptr_gray_sync[ADDR_WIDTH:ADDR_WIDTH-1], 
                                           rd_ptr_gray_sync[ADDR_WIDTH-2:0]});
    end

    //==========================================================================
    // Read Clock Domain
    //==========================================================================
    
    // Read pointer generation
    always @(posedge rd_clk or negedge rd_rst_n) begin
        if (!rd_rst_n) begin
            rd_ptr_bin <= 0;
            rd_ptr_gray <= 0;
        end else begin
            rd_ptr_bin <= rd_ptr_bin_next;
            rd_ptr_gray <= rd_ptr_gray_next;
        end
    end
    
    // Read pointer next value logic
    always @(*) begin
        rd_ptr_bin_next = rd_ptr_bin + (rd_en & ~empty);
        rd_ptr_gray_next = (rd_ptr_bin_next >> 1) ^ rd_ptr_bin_next;
    end
    
    // Memory read
    always @(posedge rd_clk or negedge rd_rst_n) begin
        if (!rd_rst_n) begin
            rd_data <= 0;
        end else if (rd_en && !empty) begin
            rd_data <= fifo_mem[rd_ptr_bin[ADDR_WIDTH-1:0]];
        end
    end
    
    // Synchronize write pointer to read clock domain
    always @(posedge rd_clk or negedge rd_rst_n) begin
        if (!rd_rst_n) begin
            wr_ptr_gray_sync_r <= 0;
            wr_ptr_gray_sync <= 0;
        end else begin
            wr_ptr_gray_sync_r <= wr_ptr_gray;
            wr_ptr_gray_sync <= wr_ptr_gray_sync_r;
        end
    end
    
    // Generate empty and almost_empty flags
    always @(*) begin
        empty = (rd_ptr_gray_next == wr_ptr_gray_sync);
    end
    
    // Almost empty generation
    wire [ADDR_WIDTH:0] rd_ptr_bin_temp = rd_ptr_bin + ALMOST_EMPTY_THRESHOLD;
    wire [ADDR_WIDTH:0] rd_ptr_gray_temp = (rd_ptr_bin_temp >> 1) ^ rd_ptr_gray_temp;
    
    always @(*) begin
        almost_empty = (rd_ptr_gray_temp == wr_ptr_gray_sync);
    end

    //==========================================================================
    // Assertions for verification (synthesis will ignore these)
    //==========================================================================
    
    `ifdef SIMULATION
        // Check for overflow
        always @(posedge wr_clk) begin
            if (wr_rst_n && wr_en && full) begin
                $error("FIFO overflow: write to full FIFO at time %t", $time);
            end
        end
        
        // Check for underflow
        always @(posedge rd_clk) begin
            if (rd_rst_n && rd_en && empty) begin
                $error("FIFO underflow: read from empty FIFO at time %t", $time);
            end
        end
        
        // Check Gray code properties
        always @(posedge wr_clk) begin
            if (wr_rst_n) begin
                assert($countones(wr_ptr_gray ^ wr_ptr_gray_next) <= 1)
                else $error("Gray code violation in write pointer at time %t", $time);
            end
        end
        
        always @(posedge rd_clk) begin
            if (rd_rst_n) begin
                assert($countones(rd_ptr_gray ^ rd_ptr_gray_next) <= 1)
                else $error("Gray code violation in read pointer at time %t", $time);
            end
        end
    `endif

endmodule
'''

    @staticmethod
    def get_assertion_template() -> str:
        return '''
// SystemVerilog Assertions for Async FIFO Verification
// Generated by Agentic AI EDA System

module fifo_assertions #(
    parameter FIFO_DEPTH = 16,
    parameter DATA_WIDTH = 8
)(
    input wire wr_clk, wr_rst_n, wr_en,
    input wire [DATA_WIDTH-1:0] wr_data,
    input wire full, almost_full,
    
    input wire rd_clk, rd_rst_n, rd_en,
    input wire [DATA_WIDTH-1:0] rd_data,
    input wire empty, almost_empty
);

    // Property: No overflow
    property no_overflow;
        @(posedge wr_clk) disable iff (!wr_rst_n)
        wr_en |-> !full;
    endproperty
    assert_no_overflow: assert property (no_overflow)
    else $error("FIFO overflow detected");

    // Property: No underflow  
    property no_underflow;
        @(posedge rd_clk) disable iff (!rd_rst_n)
        rd_en |-> !empty;
    endproperty
    assert_no_underflow: assert property (no_underflow)
    else $error("FIFO underflow detected");

    // Property: Full and empty are mutually exclusive
    property full_empty_exclusive;
        @(posedge wr_clk) disable iff (!wr_rst_n)
        !(full && empty);
    endproperty
    assert_full_empty_exclusive: assert property (full_empty_exclusive);

    // Property: Almost full implies not empty
    property almost_full_not_empty;
        @(posedge wr_clk) disable iff (!wr_rst_n)
        almost_full |-> !empty;
    endproperty
    assert_almost_full_not_empty: assert property (almost_full_not_empty);

    // Coverage for flag combinations
    covergroup fifo_flags_cg @(posedge wr_clk);
        cp_full: coverpoint full;
        cp_empty: coverpoint empty;
        cp_almost_full: coverpoint almost_full;
        cp_almost_empty: coverpoint almost_empty;
        
        // Cross coverage for all flag combinations
        cross_flags: cross cp_full, cp_empty, cp_almost_full, cp_almost_empty;
    endgroup
    
    fifo_flags_cg flags_coverage = new();

endmodule
'''


class CodeAgent(BaseAgent):
    """
    Agent responsible for SystemVerilog RTL code generation and refinement
    
    Key capabilities:
    - Generate parameterizable async FIFO RTL
    - Implement Gray code pointers
    - Create clock domain crossing logic
    - Syntax checking and compilation
    - Code refinement based on feedback
    - Generate SystemVerilog assertions
    """
    
    def __init__(self, config: AgentConfig):
        super().__init__(config)
        self.templates = RTLTemplates()
        self.current_code: Optional[str] = None
        self.current_spec: Optional[FIFOSpecification] = None
        self.iteration_count = 0
    
    def get_capabilities(self) -> List[str]:
        return [
            "generate_rtl",
            "check_syntax", 
            "refine_code",
            "generate_assertions",
            "export_code",
            "analyze_code_quality"
        ]
    
    def _execute_task_impl(self, task_name: str, **kwargs) -> Any:
        """Execute code generation tasks"""
        if task_name == "generate_rtl":
            return self._generate_rtl(kwargs.get("specification"))
        elif task_name == "check_syntax":
            return self._check_syntax(kwargs.get("code"))
        elif task_name == "refine_code":
            return self._refine_code(kwargs.get("issues", []))
        elif task_name == "generate_assertions":
            return self._generate_assertions()
        elif task_name == "export_code":
            return self._export_code(kwargs.get("output_path"))
        elif task_name == "analyze_code_quality":
            return self._analyze_code_quality()
        else:
            raise ValueError(f"Unknown task: {task_name}")
    
    def _generate_rtl(self, specification: FIFOSpecification) -> CodeGenerationResult:
        """Generate SystemVerilog RTL from specification"""
        self.logger.info("Generating SystemVerilog RTL")
        self.current_spec = specification
        self.iteration_count += 1
        
        # Start with base template
        rtl_code = self.templates.get_async_fifo_template()
        
        # Customize based on specification
        rtl_code = self._customize_template(rtl_code, specification)
        
        # Check syntax
        syntax_check = self._check_syntax(rtl_code)
        
        result = CodeGenerationResult(
            module_code=rtl_code,
            syntax_valid=syntax_check["valid"],
            warnings=syntax_check["warnings"],
            errors=syntax_check["errors"]
        )
        
        if result.syntax_valid:
            self.current_code = rtl_code
            self.logger.info("RTL generation successful")
        else:
            self.logger.warning(f"RTL generation has {len(result.errors)} errors")
        
        return result
    
    def _customize_template(self, template: str, spec: FIFOSpecification) -> str:
        """Customize template based on specification"""
        
        # Replace parameter values
        customized = template.replace("FIFO_DEPTH = 16", f"FIFO_DEPTH = {spec.parameters.depth}")
        customized = customized.replace("DATA_WIDTH = 8", f"DATA_WIDTH = {spec.parameters.data_width}")
        customized = customized.replace("ALMOST_FULL_THRESHOLD = 2", f"ALMOST_FULL_THRESHOLD = {spec.parameters.almost_full_threshold}")
        customized = customized.replace("ALMOST_EMPTY_THRESHOLD = 2", f"ALMOST_EMPTY_THRESHOLD = {spec.parameters.almost_empty_threshold}")
        
        # Customize interface signal names if different from default
        interface = spec.interface
        if interface.write_clock != "wr_clk":
            customized = customized.replace("wr_clk", interface.write_clock)
        if interface.read_clock != "rd_clk":
            customized = customized.replace("rd_clk", interface.read_clock)
        
        # Add header comment with specification details
        header = f"""
//==============================================================================
// Async FIFO: {spec.description}
// Generated by Agentic AI EDA System - Iteration {self.iteration_count}
//
// Parameters:
//   - Depth: {spec.parameters.depth} entries
//   - Data Width: {spec.parameters.data_width} bits
//   - Gray Code Pointers: {spec.constraints.gray_code_pointers}
//   - Async Clocks: {spec.constraints.async_clocks}
//   - Reset Type: {spec.constraints.reset_type}
//==============================================================================
"""
        
        customized = header + customized
        
        return customized
    
    def _check_syntax(self, code: Optional[str] = None) -> Dict[str, Any]:
        """Check SystemVerilog syntax using iverilog or similar tool"""
        if code is None:
            code = self.current_code
        
        if not code:
            return {"valid": False, "errors": ["No code to check"], "warnings": []}
        
        # Create temporary file
        with tempfile.NamedTemporaryFile(mode='w', suffix='.sv', delete=False) as f:
            f.write(code)
            temp_file = f.name
        
        try:
            # Try to compile with iverilog
            result = subprocess.run(
                ['iverilog', '-g2012', '-t', 'null', temp_file],
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.returncode == 0:
                return {
                    "valid": True,
                    "errors": [],
                    "warnings": self._parse_warnings(result.stderr)
                }
            else:
                return {
                    "valid": False,
                    "errors": self._parse_errors(result.stderr),
                    "warnings": self._parse_warnings(result.stderr)
                }
                
        except subprocess.TimeoutExpired:
            return {"valid": False, "errors": ["Compilation timeout"], "warnings": []}
        except FileNotFoundError:
            # iverilog not available, do basic syntax checking
            self.logger.warning("iverilog not available, performing basic syntax check")
            return self._basic_syntax_check(code)
        finally:
            # Clean up temporary file
            Path(temp_file).unlink(missing_ok=True)
    
    def _basic_syntax_check(self, code: str) -> Dict[str, Any]:
        """Basic syntax checking without external tools"""
        errors = []
        warnings = []
        
        # Check for basic SystemVerilog syntax
        lines = code.split('\\n')
        for i, line in enumerate(lines, 1):
            line = line.strip()
            
            # Check for missing semicolons (basic check)
            if (line.startswith(('reg ', 'wire ', 'input ', 'output ', 'assign ')) and 
                not line.endswith((';', ',', '(', ')', '{', '}')) and 
                '//' not in line):
                warnings.append(f"Line {i}: Possible missing semicolon")
            
            # Check for unmatched parentheses (basic check)
            open_parens = line.count('(')
            close_parens = line.count(')')
            if open_parens != close_parens and not line.endswith(','):
                warnings.append(f"Line {i}: Unmatched parentheses")
        
        # Check for module structure
        if 'module ' not in code:
            errors.append("No module declaration found")
        if 'endmodule' not in code:
            errors.append("No endmodule found")
        
        return {
            "valid": len(errors) == 0,
            "errors": errors,
            "warnings": warnings
        }
    
    def _parse_errors(self, stderr: str) -> List[str]:
        """Parse error messages from compiler output"""
        errors = []
        for line in stderr.split('\\n'):
            if 'error:' in line.lower():
                errors.append(line.strip())
        return errors
    
    def _parse_warnings(self, stderr: str) -> List[str]:
        """Parse warning messages from compiler output"""
        warnings = []
        for line in stderr.split('\\n'):
            if 'warning:' in line.lower():
                warnings.append(line.strip())
        return warnings
    
    def _refine_code(self, issues: List[str]) -> CodeGenerationResult:
        """Refine code based on identified issues"""
        self.logger.info(f"Refining code based on {len(issues)} issues")
        
        if not self.current_code or not issues:
            return CodeGenerationResult(
                module_code=self.current_code or "",
                syntax_valid=False,
                warnings=[],
                errors=["No code or issues to refine"]
            )
        
        refined_code = self.current_code
        
        # Apply refinements based on common issues
        for issue in issues:
            refined_code = self._apply_refinement(refined_code, issue)
        
        # Check syntax of refined code
        syntax_check = self._check_syntax(refined_code)
        
        result = CodeGenerationResult(
            module_code=refined_code,
            syntax_valid=syntax_check["valid"],
            warnings=syntax_check["warnings"],
            errors=syntax_check["errors"]
        )
        
        if result.syntax_valid:
            self.current_code = refined_code
            self.logger.info("Code refinement successful")
        else:
            self.logger.warning("Code refinement still has issues")
        
        return result
    
    def _apply_refinement(self, code: str, issue: str) -> str:
        """Apply specific refinement based on issue type"""
        
        # Fix common Gray code issues
        if "gray code" in issue.lower():
            # Fix Gray code calculation
            code = re.sub(
                r'(\w+_ptr_gray_temp)\s*=\s*\([^;]+\^\s*\1',
                r'\\1 = (\\1_bin >> 1) ^ \\1_bin',
                code
            )
        
        # Fix metastability synchronizer issues
        if "metastability" in issue.lower() or "synchronizer" in issue.lower():
            # Ensure proper 2-stage synchronizer
            if "rd_ptr_gray_sync_r" not in code:
                # Add missing synchronizer stage
                code = code.replace(
                    "rd_ptr_gray_sync <= rd_ptr_gray;",
                    "rd_ptr_gray_sync_r <= rd_ptr_gray;\\n            rd_ptr_gray_sync <= rd_ptr_gray_sync_r;"
                )
        
        # Fix reset issues
        if "reset" in issue.lower():
            # Ensure consistent reset polarity
            if self.current_spec and self.current_spec.constraints.reset_type == "async_active_high":
                code = code.replace("negedge wr_rst_n", "posedge wr_rst")
                code = code.replace("!wr_rst_n", "wr_rst")
        
        # Fix flag generation issues
        if "flag" in issue.lower() or "full" in issue.lower() or "empty" in issue.lower():
            # Fix almost_full/almost_empty calculation
            code = re.sub(
                r'wire\s+\[ADDR_WIDTH:0\]\s+rd_ptr_gray_temp\s*=.*rd_ptr_gray_temp;',
                'wire [ADDR_WIDTH:0] rd_ptr_gray_temp = (rd_ptr_bin_temp >> 1) ^ rd_ptr_bin_temp;',
                code
            )
        
        return code
    
    def _generate_assertions(self) -> str:
        """Generate SystemVerilog assertions for verification"""
        self.logger.info("Generating SystemVerilog assertions")
        
        assertions = self.templates.get_assertion_template()
        
        if self.current_spec:
            # Customize assertions based on specification
            assertions = assertions.replace("FIFO_DEPTH = 16", f"FIFO_DEPTH = {self.current_spec.parameters.depth}")
            assertions = assertions.replace("DATA_WIDTH = 8", f"DATA_WIDTH = {self.current_spec.parameters.data_width}")
        
        return assertions
    
    def _export_code(self, output_path: Optional[str] = None) -> str:
        """Export generated code to file"""
        if not self.current_code:
            raise ValueError("No code to export")
        
        if output_path is None:
            output_path = str(self.config.output_dir.parent / "rtl" / "async_fifo.sv")
        
        # Ensure directory exists
        Path(output_path).parent.mkdir(parents=True, exist_ok=True)
        
        with open(output_path, 'w') as f:
            f.write(self.current_code)
        
        # Also export assertions
        assertions_path = str(Path(output_path).parent / "fifo_assertions.sv")
        with open(assertions_path, 'w') as f:
            f.write(self._generate_assertions())
        
        self.logger.info(f"Exported code to {output_path}")
        self.logger.info(f"Exported assertions to {assertions_path}")
        
        return output_path
    
    def _analyze_code_quality(self) -> Dict[str, Any]:
        """Analyze code quality metrics"""
        if not self.current_code:
            return {"error": "No code to analyze"}
        
        lines = self.current_code.split('\\n')
        
        analysis = {
            "total_lines": len(lines),
            "code_lines": len([l for l in lines if l.strip() and not l.strip().startswith('//')]),
            "comment_lines": len([l for l in lines if l.strip().startswith('//')]),
            "blank_lines": len([l for l in lines if not l.strip()]),
            "has_assertions": "`ifdef SIMULATION" in self.current_code,
            "has_parameters": "parameter" in self.current_code,
            "clock_domains": len(re.findall(r'@\(posedge\s+\w+_clk\)', self.current_code)),
            "always_blocks": len(re.findall(r'always\s*@', self.current_code)),
            "complexity_score": self._calculate_complexity()
        }
            
        analysis["comment_ratio"] = analysis["comment_lines"] / max(analysis["code_lines"], 1)
        
        self.logger.info(f"Code quality analysis: {analysis['code_lines']} lines, {analysis['always_blocks']} always blocks")
        
        return analysis
    
    def _calculate_complexity(self) -> int:
        """Calculate cyclomatic complexity estimate"""
        if not self.current_code:
            return 0
        
        # Simple complexity estimation based on control structures
        complexity = 1  # Base complexity
        
        # Count decision points
        complexity += len(re.findall(r'\\bif\\b', self.current_code))
        complexity += len(re.findall(r'\\belse\\b', self.current_code))
        complexity += len(re.findall(r'\\bcase\\b', self.current_code))
        complexity += len(re.findall(r'\\bfor\\b', self.current_code))
        complexity += len(re.findall(r'\\bwhile\\b', self.current_code))
        complexity += len(re.findall(r'\\?.*:', self.current_code))  # Ternary operators
        
        return complexity